# Template: refactor
# Version: 2.0.0
# MAID Spec: v1.2

I need you to refactor existing code to improve its quality while maintaining the same public API and behavior.

## Task Context

**Manifest:** ${manifest_path}
**Goal:** ${goal}

## Current Implementation Status

All tests are currently passing. Your job is to improve the code quality without breaking any tests.

**Files to refactor:**
${files_to_refactor}

**Test file (must continue passing):**
${test_file}

## Your Task

Refactor the implementation to improve code quality while ensuring:
1. **All tests still pass** - No behavior changes
2. **Public API unchanged** - Same signatures, same return types
3. **Better code quality** - Apply clean code principles

### Refactoring Goals

Focus on these improvements:

**1. Code Structure:**
- Extract complex logic into private helper methods
- Reduce method/function complexity (max ~15-20 lines)
- Improve class organization
- Better separation of concerns

**2. Readability:**
- More descriptive variable names
- Better comments for complex logic
- Clearer control flow
- Consistent formatting

**3. Performance:**
- Remove unnecessary operations
- Optimize loops and conditions
- Cache repeated calculations
- Use appropriate data structures

**4. Error Handling:**
- Better exception messages
- More specific exception types
- Proper error recovery
- Defensive programming

**5. Type Safety:**
- Add missing type hints
- Use more specific types (not just `Any`)
- Add type guards where appropriate

**6. Documentation:**
- Improve docstrings
- Add examples in docstrings
- Document edge cases
- Clarify assumptions

### Refactoring Patterns

**Extract Method:**
```python
# Before - complex method
def process_data(self, data: dict) -> dict:
    """Process data."""
    # 50 lines of complex logic
    result = {}
    # validation logic
    if not data:
        return {"error": "empty"}
    # transformation logic
    for key, value in data.items():
        if isinstance(value, str):
            result[key] = value.upper()
    # formatting logic
    return {"result": result, "count": len(result)}

# After - extracted helper methods
def process_data(self, data: dict) -> dict:
    """Process data through validation, transformation, and formatting.

    Args:
        data: Input data dictionary

    Returns:
        Dict with processed results and metadata
    """
    if not self._validate_data(data):
        return {"error": "empty"}

    transformed = self._transform_data(data)
    return self._format_result(transformed)

def _validate_data(self, data: dict) -> bool:
    """Validate input data is not empty."""
    return bool(data)

def _transform_data(self, data: dict) -> dict:
    """Transform string values to uppercase."""
    return {
        key: value.upper() if isinstance(value, str) else value
        for key, value in data.items()
    }

def _format_result(self, data: dict) -> dict:
    """Format result with metadata."""
    return {"result": data, "count": len(data)}
```

**Improve Variable Names:**
```python
# Before - unclear names
def process(self, d: dict) -> dict:
    r = {}
    for k, v in d.items():
        if v:
            r[k] = v
    return r

# After - descriptive names
def process(self, data: dict) -> dict:
    """Filter out None/empty values from data."""
    filtered_data = {}
    for key, value in data.items():
        if value:
            filtered_data[key] = value
    return filtered_data
```

**Better Error Handling:**
```python
# Before - generic errors
def load_file(self, path: str) -> dict:
    try:
        with open(path) as f:
            return json.load(f)
    except Exception as e:
        return {"error": str(e)}

# After - specific errors with context
def load_file(self, path: str) -> dict:
    """Load and parse JSON file.

    Args:
        path: Path to JSON file

    Returns:
        Dict with file contents or error information
    """
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return {
            "error": f"File not found: {path}",
            "success": False
        }
    except json.JSONDecodeError as e:
        return {
            "error": f"Invalid JSON in {path}: {e}",
            "success": False
        }
    except PermissionError:
        return {
            "error": f"Permission denied reading {path}",
            "success": False
        }
    except Exception as e:
        return {
            "error": f"Unexpected error loading {path}: {e}",
            "success": False
        }
```

**Reduce Complexity:**
```python
# Before - nested conditions
def validate(self, data: dict) -> bool:
    if data:
        if "name" in data:
            if data["name"]:
                if isinstance(data["name"], str):
                    if len(data["name"]) > 0:
                        return True
    return False

# After - early returns
def validate(self, data: dict) -> bool:
    """Validate data has non-empty name string.

    Args:
        data: Data dictionary to validate

    Returns:
        True if valid, False otherwise
    """
    if not data:
        return False

    if "name" not in data:
        return False

    name = data["name"]
    if not isinstance(name, str):
        return False

    return len(name) > 0
```

**Use Type Hints:**
```python
# Before - missing types
def process(self, data):
    result = []
    for item in data:
        result.append(transform(item))
    return result

# After - with types
from typing import List, Any

def process(self, data: List[Any]) -> List[str]:
    """Process list of items and transform to strings.

    Args:
        data: List of items to process

    Returns:
        List of transformed string results
    """
    return [self._transform_item(item) for item in data]

def _transform_item(self, item: Any) -> str:
    """Transform single item to string representation."""
    return str(item).upper()
```

### Example Refactoring from MAID Agents

**Before (functional but verbose):**
```python
def create_manifest(self, goal: str, task_number: int) -> dict:
    """Create manifest from goal description."""
    self.logger.debug(f"Creating manifest for task-{task_number:03d}: {goal[:60]}...")

    response = self._generate_manifest_with_claude(goal, task_number)
    if not response.success:
        self.logger.error(f"Manifest creation failed: {response.error}")
        return {
            "success": False,
            "error": response.error,
            "manifest_path": None,
            "manifest_data": None,
        }

    slug = self._generate_slug(goal)
    manifest_path = f"manifests/task-{task_number:03d}-{slug}.manifest.json"

    try:
        with open(manifest_path) as f:
            manifest_data = json.load(f)
    except FileNotFoundError:
        error_msg = (
            f"Manifest file {manifest_path} was not created by Claude Code. "
            "Ensure Claude Code writes the manifest file directly."
        )
        self.logger.error(f"Manifest creation failed: {error_msg}")
        return {
            "success": False,
            "error": error_msg,
            "manifest_path": None,
            "manifest_data": None,
        }
    except json.JSONDecodeError as e:
        error_msg = f"Invalid JSON in generated manifest: {e}"
        self.logger.error(f"Manifest creation failed: {error_msg}")
        return {
            "success": False,
            "error": error_msg,
            "manifest_path": None,
            "manifest_data": None,
        }

    self.logger.info(f"Successfully created manifest: {manifest_path}")
    return {
        "success": True,
        "manifest_path": manifest_path,
        "manifest_data": manifest_data,
        "error": None,
    }
```

**After (cleaner with extracted methods):**
```python
def create_manifest(self, goal: str, task_number: int) -> dict:
    """Create manifest from goal description.

    Args:
        goal: High-level goal description
        task_number: Task number for manifest naming

    Returns:
        Dict with manifest creation results
    """
    self.logger.debug(
        f"Creating manifest for task-{task_number:03d}: "
        f"{goal[:self._GOAL_PREVIEW_LENGTH]}..."
    )

    # Generate manifest using Claude Code
    response = self._generate_manifest_with_claude(goal, task_number)
    if not response.success:
        return self._build_error_response(response.error)

    # Create manifest path
    manifest_path = self._build_manifest_path(goal, task_number)

    # Read the generated manifest from disk
    manifest_data = self._load_manifest_file(manifest_path)
    if manifest_data is None:
        return self._build_error_response(
            f"Failed to load manifest from {manifest_path}"
        )

    self.logger.info(f"Successfully created manifest: {manifest_path}")
    return self._build_success_response(manifest_path, manifest_data)

def _load_manifest_file(self, manifest_path: str) -> Optional[dict]:
    """Load and parse manifest JSON file.

    Args:
        manifest_path: Path to manifest file

    Returns:
        Parsed manifest data, or None if loading failed
    """
    try:
        with open(manifest_path) as f:
            return json.load(f)
    except FileNotFoundError:
        self.logger.error(
            f"Manifest file {manifest_path} was not created by Claude Code. "
            "Ensure Claude Code writes the manifest file directly."
        )
        return None
    except json.JSONDecodeError as e:
        self.logger.error(f"Invalid JSON in generated manifest: {e}")
        return None

def _build_error_response(self, error: str) -> dict:
    """Build standardized error response.

    Args:
        error: Error message to include

    Returns:
        Dict with error information
    """
    self.logger.error(f"Manifest creation failed: {error}")
    return {
        "success": False,
        "error": error,
        "manifest_path": None,
        "manifest_data": None,
    }

def _build_success_response(self, manifest_path: str, manifest_data: dict) -> dict:
    """Build standardized success response.

    Args:
        manifest_path: Path to the manifest file
        manifest_data: Parsed manifest data

    Returns:
        Dict with success information
    """
    return {
        "success": True,
        "manifest_path": manifest_path,
        "manifest_data": manifest_data,
        "error": None,
    }
```

## Refactoring Checklist

Before submitting your refactored code, verify:

- ✅ All existing tests still pass
- ✅ Public API signatures unchanged
- ✅ No new public methods/functions (only private helpers)
- ✅ Better variable/function names
- ✅ Reduced complexity (shorter methods)
- ✅ Better error handling
- ✅ Improved type hints
- ✅ Better docstrings
- ✅ No performance regressions
- ✅ Code follows Python conventions (PEP 8)

## What NOT to Do

- ❌ **Don't change public API** - Method signatures must stay the same
- ❌ **Don't change behavior** - Tests must continue passing
- ❌ **Don't add features** - This is refactoring, not enhancement
- ❌ **Don't over-engineer** - Keep it simple and readable
- ❌ **Don't break dependencies** - Other code depends on this

## File Access Boundaries

For this refactoring phase, you should:
- **Read:** Implementation files, test files, manifest
- **Edit:** Only the files listed in `${files_to_refactor}`
- **Do NOT modify:** Test files or the manifest
- **Do NOT create:** New files (refactoring improves existing code)

This ensures proper isolation and traceability in the MAID methodology.

## Next Steps

1. Read the current implementation to understand the code
2. Run tests to ensure they pass before refactoring
3. Apply refactoring patterns to improve code quality
4. Use your Edit tool to update the implementation files
5. Verify tests still pass after refactoring

Please proceed with the refactoring!
